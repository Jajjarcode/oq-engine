# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4
"""Codec for processing vulnerability curves
from XML files.

A DOM version of the vulnerability model parser,
that takes into account the really small size of this input file.

"""

from lxml import etree
from ordereddict import OrderedDict

from opengem import state
from opengem import shapes

STATE = state.STATE

"""
TODO I've realized we shouldn't assume that STATE is 
writable at import time, so this stuff should probably get
tucked into the register_vuln_curve method, below, in an
if: block. But you can leave that for the STATE
refactor if you want.
"""

EMPTY_CODE = 'EMPTY'
STATE['vulnerability_curves'] = {}
STATE['vulnerability_curves'][EMPTY_CODE] = shapes.EMPTY_CURVE

def register_vuln_curve(code, curve):
    """Store processed curve in global state datastore."""
    STATE['vulnerability_curves'][code] = curve

def load_vulnerability_model(path):
    """Loads and registers all the vulnerability functions defined."""
    
    vulnerability_model = etree.parse(path).getroot()
    
    for vulnerability_function in vulnerability_model:
        # parse values
        intensity_measure_values = map(
                float, vulnerability_function.find(
                'IntensityMeasureValues').text.strip().split())

        loss_ratio_values = map(
    	        float, vulnerability_function.find(
    	        'LossRatioValues').text.strip().split())

        coefficient_variation_values = map(
    	        float, vulnerability_function.find(
    	        'CoefficientVariationValues').text.strip().split())

        # convert raw values into our object model
        curve_data = []
        pairs = zip(loss_ratio_values, coefficient_variation_values)
        
        for idx, IML in enumerate(intensity_measure_values):
            curve_data.append(('%s' % IML, pairs[idx]))
        
        register_vuln_curve(vulnerability_function.attrib['ID'],
                shapes.FastCurve(curve_data))