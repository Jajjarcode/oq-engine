# -*- coding: utf-8 -*-
"""
A simple memcached reader.
"""

import json
import math
import pylibmc

from opengem import identifiers
from opengem import shapes

MEMCACHED_PORT = 11211
MEMCACHED_HOST = "localhost"

class Reader(object):
    """Read objects from memcached and translate them into
    our object model.
    """
    
    def __init__(self, client):
        self.client = client
    
    def _check_key_in_cache(self, key):
        """Raise an error if the given key is not in memcached."""
        
        if not self.client.get(key):
            raise ValueError("There's no value for key %s!" % key)
        
    def as_curve(self, key):
        """Read serialized versions of hazard curves
        and produce shapes.FastCurve objects.
        
        TODO (ac): How should we handle other metadata?
        """
        
        decoded_model = self._get_and_decode(key)
        
        curves = []
        
        for raw_curves in decoded_model["hcRepList"]:
            for curve in raw_curves["probExList"]:
                curves.append(shapes.FastCurve(
                        zip(raw_curves["gmLevels"], curve)))
        
        return curves
    
    def _get_and_decode(self, key):
        """Get the value from cache and return the decoded object."""
        
        self._check_key_in_cache(key)
        return json.JSONDecoder().decode(self.client.get(key))
    
    def for_shaml(self, key):
        """Read serialized versions of hazard curves
        and produce a dictionary as expected by the shaml writer.
        
        TODO (ac): What about make this generated by an improved
        version of the Curve object?
        """
        
        decoded_model = self._get_and_decode(key)
        
        curves = {}
        
        for set_counter, raw_curves in enumerate(decoded_model["hcRepList"]):
            
            for curve_counter, curve in enumerate(raw_curves["probExList"]):
                data = {}
                
                data["IDmodel"] = "FIXED" # fixed, not yet implemented
                data["vs30"] = 0.0 # fixed, not yet implemented
                data["timeSpanDuration"] = raw_curves["timeSpan"]
                data["IMT"] = raw_curves["intensityMeasureType"]
                data["Values"] = curve
                data["IML"] = raw_curves["gmLevels"]
                data["maxProb"] = curve[-1]
                data["minProb"] = curve[0]
                data["endBranchLabel"] = \
                        decoded_model["endBranchLabels"][set_counter]
                
                """
                Longitude and latitude and stored internally in the Java side
                in radians. That object (org.opensha.commons.geo.Location) is
                heavily used in the hazard engine and we don't have unit
                tests, so I prefer to convert to decimal degrees here.
                """
                lon = raw_curves["gridNode"][curve_counter]["location"]["lon"]
                lat = raw_curves["gridNode"][curve_counter]["location"]["lat"]
                
                curves[shapes.Site(math.degrees(lon), math.degrees(lat))] = data

        return curves


def get_client(memcached_host=MEMCACHED_HOST, memcached_port=MEMCACHED_PORT,
               **kwargs):
    """possible kwargs:
        binary
    """
    return pylibmc.Client(["%s:%d" % (memcached_host, memcached_port)], 
                          **kwargs)

def get_value_json_decoded(memcache_client, key):
    value = memcache_client.get(key)
    decoder = json.JSONDecoder()
    try:
        return decoder.decode(value)
    except Exception:
        return None

def set_value_json_encoded(memcache_client, key, value):
    encoder = json.JSONEncoder()

    try:
        encoded_value = encoder.encode(value)
    except Exception:
        raise ValueError("cannot encode value %s to JSON" % value)

    try:
        memcache_client.set(key, encoded_value)
    except Exception:
        raise RuntimeError("cannot write key %s to memcache" % key)

    return True

def get_sites_from_memcache(memcache_client, job_id, block_id):

    memcache_key_sites = identifiers.generate_product_key(
        job_id, block_id, None, identifiers.SITES_KEY_TOKEN)

    return get_value_json_decoded(memcache_client, memcache_key_sites)
    